rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Sounds collection
    match /sounds/{soundId} {
      // Anyone can read sounds
      allow read: if true;

      // Anyone can create sounds with basic validation
      allow create: if request.resource.data.keys().hasAll(['name', 'category', 'fileName'])
                       && request.resource.data.name is string
                       && request.resource.data.name.size() > 0
                       && request.resource.data.name.size() <= 100
                       && request.resource.data.category in ['classic', 'modern', 'futuristic', 'custom', 'funny', 'musical'];

      // Only allow updating likes and downloads fields (for like/download counters)
      allow update: if request.resource.data.diff(resource.data)
                       .affectedKeys().hasOnly(['likes', 'downloads']);

      // Only admins can delete sounds
      allow delete: if request.auth != null &&
                       exists(/databases/$(database)/documents/admins/$(request.auth.token.email));
    }

    // Admins collection - only readable by the admin themselves
    match /admins/{email} {
      // Admin can read their own document to verify admin status
      allow read: if request.auth != null &&
                     request.auth.token.email.lower() == email.lower();

      // No one can write to admins collection via client SDK
      // Admins should be added manually via Firebase Console
      allow write: if false;
    }

    // Product analytics events
    match /events/{eventId} {
      // Only admins can read analytics
      allow read: if request.auth != null &&
                     exists(/databases/$(database)/documents/admins/$(request.auth.token.email));

      // Anonymous write allowed with field validation
      allow create: if request.resource.data.keys().hasAll([
                       'eventName',
                       'occurredAtMs',
                       'userId',
                       'sessionId',
                       'language',
                       'entryChannel',
                       'device',
                       'path'
                     ])
                     && request.resource.data.eventName is string
                     && request.resource.data.eventName.size() > 0
                     && request.resource.data.eventName.size() <= 80
                     && request.resource.data.occurredAtMs is int
                     && request.resource.data.userId is string
                     && request.resource.data.sessionId is string
                     && request.resource.data.language is string
                     && request.resource.data.entryChannel is string
                     && request.resource.data.device in ['desktop', 'mobile', 'tablet']
                     && request.resource.data.path is string;

      allow update, delete: if false;
    }

    // User dashboard layouts
    match /dashboards/{dashboardId} {
      allow read: if true;

      allow create: if request.auth != null
                    && request.resource.data.ownerUid == request.auth.uid
                    && request.resource.data.publicId is string
                    && request.resource.data.config is map;

      allow update: if request.auth != null
                    && resource.data.ownerUid == request.auth.uid
                    && request.resource.data.ownerUid == request.auth.uid;

      allow delete: if request.auth != null
                    && resource.data.ownerUid == request.auth.uid;
    }

    // Lookup aliases for email/public dashboard id
    match /dashboardAliases/{aliasId} {
      allow read: if true;

      allow create: if request.auth != null
                    && request.resource.data.ownerUid == request.auth.uid
                    && request.resource.data.dashboardId is string;

      allow update: if request.auth != null
                    && resource.data.ownerUid == request.auth.uid
                    && request.resource.data.ownerUid == request.auth.uid;

      allow delete: if request.auth != null
                    && resource.data.ownerUid == request.auth.uid;
    }

    // Deny access to all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
